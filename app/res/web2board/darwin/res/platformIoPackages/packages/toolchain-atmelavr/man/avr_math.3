.TH "<math.h>: Mathematics" 3 "Thu Dec 29 2011" "Version 1.8.0" "avr-libc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
<math.h>: Mathematics \- 
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBM_E\fP   2\&.7182818284590452354"
.br
.ti -1c
.RI "#define \fBM_LOG2E\fP   1\&.4426950408889634074	/* log_2 e */"
.br
.ti -1c
.RI "#define \fBM_LOG10E\fP   0\&.43429448190325182765	/* log_10 e */"
.br
.ti -1c
.RI "#define \fBM_LN2\fP   0\&.69314718055994530942	/* log_e 2 */"
.br
.ti -1c
.RI "#define \fBM_LN10\fP   2\&.30258509299404568402	/* log_e 10 */"
.br
.ti -1c
.RI "#define \fBM_PI\fP   3\&.14159265358979323846	/* pi */"
.br
.ti -1c
.RI "#define \fBM_PI_2\fP   1\&.57079632679489661923	/* pi/2 */"
.br
.ti -1c
.RI "#define \fBM_PI_4\fP   0\&.78539816339744830962	/* pi/4 */"
.br
.ti -1c
.RI "#define \fBM_1_PI\fP   0\&.31830988618379067154	/* 1/pi */"
.br
.ti -1c
.RI "#define \fBM_2_PI\fP   0\&.63661977236758134308	/* 2/pi */"
.br
.ti -1c
.RI "#define \fBM_2_SQRTPI\fP   1\&.12837916709551257390	/* 2/\fBsqrt\fP(pi) */"
.br
.ti -1c
.RI "#define \fBM_SQRT2\fP   1\&.41421356237309504880	/* \fBsqrt\fP(2) */"
.br
.ti -1c
.RI "#define \fBM_SQRT1_2\fP   0\&.70710678118654752440	/* 1/\fBsqrt\fP(2) */"
.br
.ti -1c
.RI "#define \fBNAN\fP   __builtin_nan('')"
.br
.ti -1c
.RI "#define \fBINFINITY\fP   __builtin_inf()"
.br
.ti -1c
.RI "#define \fBcosf\fP   \fBcos\fP"
.br
.ti -1c
.RI "#define \fBsinf\fP   \fBsin\fP"
.br
.ti -1c
.RI "#define \fBtanf\fP   \fBtan\fP"
.br
.ti -1c
.RI "#define \fBfabsf\fP   \fBfabs\fP"
.br
.ti -1c
.RI "#define \fBfmodf\fP   \fBfmod\fP"
.br
.ti -1c
.RI "#define \fBsqrtf\fP   \fBsqrt\fP"
.br
.ti -1c
.RI "#define \fBcbrtf\fP   \fBcbrt\fP"
.br
.ti -1c
.RI "#define \fBhypotf\fP   \fBhypot\fP"
.br
.ti -1c
.RI "#define \fBsquaref\fP   \fBsquare\fP"
.br
.ti -1c
.RI "#define \fBfloorf\fP   \fBfloor\fP"
.br
.ti -1c
.RI "#define \fBceilf\fP   \fBceil\fP"
.br
.ti -1c
.RI "#define \fBfrexpf\fP   \fBfrexp\fP"
.br
.ti -1c
.RI "#define \fBldexpf\fP   \fBldexp\fP"
.br
.ti -1c
.RI "#define \fBexpf\fP   \fBexp\fP"
.br
.ti -1c
.RI "#define \fBcoshf\fP   \fBcosh\fP"
.br
.ti -1c
.RI "#define \fBsinhf\fP   \fBsinh\fP"
.br
.ti -1c
.RI "#define \fBtanhf\fP   \fBtanh\fP"
.br
.ti -1c
.RI "#define \fBacosf\fP   \fBacos\fP"
.br
.ti -1c
.RI "#define \fBasinf\fP   \fBasin\fP"
.br
.ti -1c
.RI "#define \fBatanf\fP   \fBatan\fP"
.br
.ti -1c
.RI "#define \fBatan2f\fP   \fBatan2\fP"
.br
.ti -1c
.RI "#define \fBlogf\fP   \fBlog\fP"
.br
.ti -1c
.RI "#define \fBlog10f\fP   \fBlog10\fP"
.br
.ti -1c
.RI "#define \fBpowf\fP   \fBpow\fP"
.br
.ti -1c
.RI "#define \fBisnanf\fP   \fBisnan\fP"
.br
.ti -1c
.RI "#define \fBisinff\fP   \fBisinf\fP"
.br
.ti -1c
.RI "#define \fBisfinitef\fP   \fBisfinite\fP"
.br
.ti -1c
.RI "#define \fBcopysignf\fP   \fBcopysign\fP"
.br
.ti -1c
.RI "#define \fBsignbitf\fP   \fBsignbit\fP"
.br
.ti -1c
.RI "#define \fBfdimf\fP   \fBfdim\fP"
.br
.ti -1c
.RI "#define \fBfmaf\fP   \fBfma\fP"
.br
.ti -1c
.RI "#define \fBfmaxf\fP   \fBfmax\fP"
.br
.ti -1c
.RI "#define \fBfminf\fP   \fBfmin\fP"
.br
.ti -1c
.RI "#define \fBtruncf\fP   \fBtrunc\fP"
.br
.ti -1c
.RI "#define \fBroundf\fP   \fBround\fP"
.br
.ti -1c
.RI "#define \fBlroundf\fP   \fBlround\fP"
.br
.ti -1c
.RI "#define \fBlrintf\fP   \fBlrint\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBcos\fP (double __x)"
.br
.ti -1c
.RI "double \fBsin\fP (double __x)"
.br
.ti -1c
.RI "double \fBtan\fP (double __x)"
.br
.ti -1c
.RI "double \fBfabs\fP (double __x)"
.br
.ti -1c
.RI "double \fBfmod\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBmodf\fP (double __x, double *__iptr)"
.br
.ti -1c
.RI "float \fBmodff\fP (float __x, float *__iptr)"
.br
.ti -1c
.RI "double \fBsqrt\fP (double __x)"
.br
.ti -1c
.RI "double \fBcbrt\fP (double __x)"
.br
.ti -1c
.RI "double \fBhypot\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBsquare\fP (double __x)"
.br
.ti -1c
.RI "double \fBfloor\fP (double __x)"
.br
.ti -1c
.RI "double \fBceil\fP (double __x)"
.br
.ti -1c
.RI "double \fBfrexp\fP (double __x, int *__pexp)"
.br
.ti -1c
.RI "double \fBldexp\fP (double __x, int __exp)"
.br
.ti -1c
.RI "double \fBexp\fP (double __x)"
.br
.ti -1c
.RI "double \fBcosh\fP (double __x)"
.br
.ti -1c
.RI "double \fBsinh\fP (double __x)"
.br
.ti -1c
.RI "double \fBtanh\fP (double __x)"
.br
.ti -1c
.RI "double \fBacos\fP (double __x)"
.br
.ti -1c
.RI "double \fBasin\fP (double __x)"
.br
.ti -1c
.RI "double \fBatan\fP (double __x)"
.br
.ti -1c
.RI "double \fBatan2\fP (double __y, double __x)"
.br
.ti -1c
.RI "double \fBlog\fP (double __x)"
.br
.ti -1c
.RI "double \fBlog10\fP (double __x)"
.br
.ti -1c
.RI "double \fBpow\fP (double __x, double __y)"
.br
.ti -1c
.RI "int \fBisnan\fP (double __x)"
.br
.ti -1c
.RI "int \fBisinf\fP (double __x)"
.br
.ti -1c
.RI "static int \fBisfinite\fP (double __x)"
.br
.ti -1c
.RI "static double \fBcopysign\fP (double __x, double __y)"
.br
.ti -1c
.RI "int \fBsignbit\fP (double __x)"
.br
.ti -1c
.RI "double \fBfdim\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBfma\fP (double __x, double __y, double __z)"
.br
.ti -1c
.RI "double \fBfmax\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBfmin\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBtrunc\fP (double __x)"
.br
.ti -1c
.RI "double \fBround\fP (double __x)"
.br
.ti -1c
.RI "long \fBlround\fP (double __x)"
.br
.ti -1c
.RI "long \fBlrint\fP (double __x)"
.br
.in -1c
.SH "Detailed Description"
.PP 
.PP
.nf
 #include <math\&.h> 
.fi
.PP
.PP
This header file declares basic mathematics constants and functions\&.
.PP
\fBNotes:\fP
.RS 4

.IP "\(bu" 2
In order to access the functions declared herein, it is usually also required to additionally link against the library \fClibm\&.a\fP\&. See also the related \fBFAQ entry\fP\&.
.IP "\(bu" 2
Math functions do not raise exceptions and do not change the \fCerrno\fP variable\&. Therefore the majority of them are declared with const attribute, for better optimization by GCC\&. 
.PP
.RE
.PP

.SH "Define Documentation"
.PP 
.SS "#define \fBacosf\fP   \fBacos\fP"The alias for \fBacos()\fP\&. 
.SS "#define \fBasinf\fP   \fBasin\fP"The alias for \fBasin()\fP\&. 
.SS "#define \fBatan2f\fP   \fBatan2\fP"The alias for \fBatan2()\fP\&. 
.SS "#define \fBatanf\fP   \fBatan\fP"The alias for \fBatan()\fP\&. 
.SS "#define \fBcbrtf\fP   \fBcbrt\fP"The alias for \fBcbrt()\fP\&. 
.SS "#define \fBceilf\fP   \fBceil\fP"The alias for \fBceil()\fP\&. 
.SS "#define \fBcopysignf\fP   \fBcopysign\fP"The alias for \fBcopysign()\fP\&. 
.SS "#define \fBcosf\fP   \fBcos\fP"The alias for \fBcos()\fP\&. 
.SS "#define \fBcoshf\fP   \fBcosh\fP"The alias for \fBcosh()\fP\&. 
.SS "#define \fBexpf\fP   \fBexp\fP"The alias for \fBexp()\fP\&. 
.SS "#define \fBfabsf\fP   \fBfabs\fP"The alias for \fBfabs()\fP\&. 
.SS "#define \fBfdimf\fP   \fBfdim\fP"The alias for \fBfdim()\fP\&. 
.SS "#define \fBfloorf\fP   \fBfloor\fP"The alias for \fBfloor()\fP\&. 
.SS "#define \fBfmaf\fP   \fBfma\fP"The alias for \fBfma()\fP\&. 
.SS "#define \fBfmaxf\fP   \fBfmax\fP"The alias for \fBfmax()\fP\&. 
.SS "#define \fBfminf\fP   \fBfmin\fP"The alias for \fBfmin()\fP\&. 
.SS "#define \fBfmodf\fP   \fBfmod\fP"The alias for \fBfmod()\fP\&. 
.SS "#define \fBfrexpf\fP   \fBfrexp\fP"The alias for \fBfrexp()\fP\&. 
.SS "#define \fBhypotf\fP   \fBhypot\fP"The alias for \fBhypot()\fP\&. 
.SS "#define \fBINFINITY\fP   __builtin_inf()"INFINITY constant\&. 
.SS "#define \fBisfinitef\fP   \fBisfinite\fP"The alias for \fBisfinite()\fP\&. 
.SS "#define \fBisinff\fP   \fBisinf\fP"The alias for \fBisinf()\fP\&. 
.SS "#define \fBisnanf\fP   \fBisnan\fP"The alias for \fBisnan()\fP\&. 
.SS "#define \fBldexpf\fP   \fBldexp\fP"The alias for \fBldexp()\fP\&. 
.SS "#define \fBlog10f\fP   \fBlog10\fP"The alias for \fBlog10()\fP\&. 
.SS "#define \fBlogf\fP   \fBlog\fP"The alias for \fBlog()\fP\&. 
.SS "#define \fBlrintf\fP   \fBlrint\fP"The alias for \fBlrint()\fP\&. 
.SS "#define \fBlroundf\fP   \fBlround\fP"The alias for \fBlround()\fP\&. 
.SS "#define \fBM_1_PI\fP   0\&.31830988618379067154	/* 1/pi */"The constant \fI1/pi\fP\&. 
.SS "#define \fBM_2_PI\fP   0\&.63661977236758134308	/* 2/pi */"The constant \fI2/pi\fP\&. 
.SS "#define \fBM_2_SQRTPI\fP   1\&.12837916709551257390	/* 2/\fBsqrt\fP(pi) */"The constant \fI2/sqrt\fP(pi)\&. 
.SS "#define \fBM_E\fP   2\&.7182818284590452354"The constant \fIe\fP\&. 
.SS "#define \fBM_LN10\fP   2\&.30258509299404568402	/* log_e 10 */"The natural logarithm of the 10\&. 
.SS "#define \fBM_LN2\fP   0\&.69314718055994530942	/* log_e 2 */"The natural logarithm of the 2\&. 
.SS "#define \fBM_LOG10E\fP   0\&.43429448190325182765	/* log_10 e */"The logarithm of the \fIe\fP to base 10\&. 
.SS "#define \fBM_LOG2E\fP   1\&.4426950408889634074	/* log_2 e */"The logarithm of the \fIe\fP to base 2\&. 
.SS "#define \fBM_PI\fP   3\&.14159265358979323846	/* pi */"The constant \fIpi\fP\&. 
.SS "#define \fBM_PI_2\fP   1\&.57079632679489661923	/* pi/2 */"The constant \fIpi/2\fP\&. 
.SS "#define \fBM_PI_4\fP   0\&.78539816339744830962	/* pi/4 */"The constant \fIpi/4\fP\&. 
.SS "#define \fBM_SQRT1_2\fP   0\&.70710678118654752440	/* 1/\fBsqrt\fP(2) */"The constant \fI1/sqrt\fP(2)\&. 
.SS "#define \fBM_SQRT2\fP   1\&.41421356237309504880	/* \fBsqrt\fP(2) */"The square root of 2\&. 
.SS "#define \fBNAN\fP   __builtin_nan('')"NAN constant\&. 
.SS "#define \fBpowf\fP   \fBpow\fP"The alias for \fBpow()\fP\&. 
.SS "#define \fBroundf\fP   \fBround\fP"The alias for \fBround()\fP\&. 
.SS "#define \fBsignbitf\fP   \fBsignbit\fP"The alias for \fBsignbit()\fP\&. 
.SS "#define \fBsinf\fP   \fBsin\fP"The alias for \fBsin()\fP\&. 
.SS "#define \fBsinhf\fP   \fBsinh\fP"The alias for \fBsinh()\fP\&. 
.SS "#define \fBsqrtf\fP   \fBsqrt\fP"The alias for \fBsqrt()\fP\&. 
.SS "#define \fBsquaref\fP   \fBsquare\fP"The alias for \fBsquare()\fP\&. 
.SS "#define \fBtanf\fP   \fBtan\fP"The alias for \fBtan()\fP\&. 
.SS "#define \fBtanhf\fP   \fBtanh\fP"The alias for \fBtanh()\fP\&. 
.SS "#define \fBtruncf\fP   \fBtrunc\fP"The alias for \fBtrunc()\fP\&. 
.SH "Function Documentation"
.PP 
.SS "double \fBacos\fP (double__x)"The \fBacos()\fP function computes the principal value of the arc cosine of \fI__x\fP\&. The returned value is in the range [0, pi] radians\&. A domain error occurs for arguments not in the range [-1, +1]\&. 
.SS "double \fBasin\fP (double__x)"The \fBasin()\fP function computes the principal value of the arc sine of \fI__x\fP\&. The returned value is in the range [-pi/2, pi/2] radians\&. A domain error occurs for arguments not in the range [-1, +1]\&. 
.SS "double \fBatan\fP (double__x)"The \fBatan()\fP function computes the principal value of the arc tangent of \fI__x\fP\&. The returned value is in the range [-pi/2, pi/2] radians\&. 
.SS "double \fBatan2\fP (double__y, double__x)"The \fBatan2()\fP function computes the principal value of the arc tangent of \fI__y / __x\fP, using the signs of both arguments to determine the quadrant of the return value\&. The returned value is in the range [-pi, +pi] radians\&. 
.SS "double \fBcbrt\fP (double__x)"The \fBcbrt()\fP function returns the cube root of \fI__x\fP\&. 
.SS "double \fBceil\fP (double__x)"The \fBceil()\fP function returns the smallest integral value greater than or equal to \fI__x\fP, expressed as a floating-point number\&. 
.SS "static double \fBcopysign\fP (double__x, double__y)\fC [static]\fP"The \fBcopysign()\fP function returns \fI__x\fP but with the sign of \fI__y\fP\&. They work even if \fI__x\fP or \fI__y\fP are NaN or zero\&. 
.SS "double \fBcos\fP (double__x)"The \fBcos()\fP function returns the cosine of \fI__x\fP, measured in radians\&. 
.SS "double \fBcosh\fP (double__x)"The \fBcosh()\fP function returns the hyperbolic cosine of \fI__x\fP\&. 
.SS "double \fBexp\fP (double__x)"The \fBexp()\fP function returns the exponential value of \fI__x\fP\&. 
.SS "double \fBfabs\fP (double__x)"The \fBfabs()\fP function computes the absolute value of a floating-point number \fI__x\fP\&. 
.SS "double \fBfdim\fP (double__x, double__y)"The \fBfdim()\fP function returns \fImax(__x - __y, 0)\fP\&. If \fI__x\fP or \fI__y\fP or both are NaN, NaN is returned\&. 
.SS "double \fBfloor\fP (double__x)"The \fBfloor()\fP function returns the largest integral value less than or equal to \fI__x\fP, expressed as a floating-point number\&. 
.SS "double \fBfma\fP (double__x, double__y, double__z)"The \fBfma()\fP function performs floating-point multiply-add\&. This is the operation \fI(__x * __y) + __z\fP, but the intermediate result is not rounded to the destination type\&. This can sometimes improve the precision of a calculation\&. 
.SS "double \fBfmax\fP (double__x, double__y)"The \fBfmax()\fP function returns the greater of the two values \fI__x\fP and \fI__y\fP\&. If an argument is NaN, the other argument is returned\&. If both arguments are NaN, NaN is returned\&. 
.SS "double \fBfmin\fP (double__x, double__y)"The \fBfmin()\fP function returns the lesser of the two values \fI__x\fP and \fI__y\fP\&. If an argument is NaN, the other argument is returned\&. If both arguments are NaN, NaN is returned\&. 
.SS "double \fBfmod\fP (double__x, double__y)"The function \fBfmod()\fP returns the floating-point remainder of \fI__x / __y\fP\&. 
.SS "double \fBfrexp\fP (double__x, int *__pexp)"The \fBfrexp()\fP function breaks a floating-point number into a normalized fraction and an integral power of 2\&. It stores the integer in the \fCint\fP object pointed to by \fI__pexp\fP\&.
.PP
If \fI__x\fP is a normal float point number, the \fBfrexp()\fP function returns the value \fCv\fP, such that \fCv\fP has a magnitude in the interval [1/2, 1) or zero, and \fI__x\fP equals \fCv\fP times 2 raised to the power \fI__pexp\fP\&. If \fI__x\fP is zero, both parts of the result are zero\&. If \fI__x\fP is not a finite number, the \fBfrexp()\fP returns \fI__x\fP as is and stores 0 by \fI__pexp\fP\&.
.PP
\fBNote:\fP
.RS 4
This implementation permits a zero pointer as a directive to skip a storing the exponent\&. 
.RE
.PP

.SS "double \fBhypot\fP (double__x, double__y)"The \fBhypot()\fP function returns \fIsqrt(__x*__x + __y*__y)\fP\&. This is the length of the hypotenuse of a right triangle with sides of length \fI__x\fP and \fI__y\fP, or the distance of the point (\fI__x\fP, \fI__y\fP) from the origin\&. Using this function instead of the direct formula is wise, since the error is much smaller\&. No underflow with small \fI__x\fP and \fI__y\fP\&. No overflow if result is in range\&. 
.SS "static int \fBisfinite\fP (double__x)\fC [static]\fP"The \fBisfinite()\fP function returns a nonzero value if \fI__x\fP is finite: not plus or minus infinity, and not NaN\&. 
.SS "int \fBisinf\fP (double__x)"The function \fBisinf()\fP returns 1 if the argument \fI__x\fP is positive infinity, -1 if \fI__x\fP is negative infinity, and 0 otherwise\&.
.PP
\fBNote:\fP
.RS 4
The GCC 4\&.3 can replace this function with inline code that returns the 1 value for both infinities (gcc bug #35509)\&. 
.RE
.PP

.SS "int \fBisnan\fP (double__x)"The function \fBisnan()\fP returns 1 if the argument \fI__x\fP represents a 'not-a-number' (NaN) object, otherwise 0\&. 
.SS "double \fBldexp\fP (double__x, int__exp)"The \fBldexp()\fP function multiplies a floating-point number by an integral power of 2\&. It returns the value of \fI__x\fP times 2 raised to the power \fI__exp\fP\&. 
.SS "double \fBlog\fP (double__x)"The \fBlog()\fP function returns the natural logarithm of argument \fI__x\fP\&. 
.SS "double \fBlog10\fP (double__x)"The \fBlog10()\fP function returns the logarithm of argument \fI__x\fP to base 10\&. 
.SS "long \fBlrint\fP (double__x)"The \fBlrint()\fP function rounds \fI__x\fP to the nearest integer, rounding the halfway cases to the even integer direction\&. (That is both 1\&.5 and 2\&.5 values are rounded to 2)\&. This function is similar to rint() function, but it differs in type of return value and in that an overflow is possible\&.
.PP
\fBReturns:\fP
.RS 4
The rounded long integer value\&. If \fI__x\fP is not a finite number or an overflow was, this realization returns the \fCLONG_MIN\fP value (0x80000000)\&. 
.RE
.PP

.SS "long \fBlround\fP (double__x)"The \fBlround()\fP function rounds \fI__x\fP to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer)\&. This function is similar to \fBround()\fP function, but it differs in type of return value and in that an overflow is possible\&.
.PP
\fBReturns:\fP
.RS 4
The rounded long integer value\&. If \fI__x\fP is not a finite number or an overflow was, this realization returns the \fCLONG_MIN\fP value (0x80000000)\&. 
.RE
.PP

.SS "double \fBmodf\fP (double__x, double *__iptr)"The \fBmodf()\fP function breaks the argument \fI__x\fP into integral and fractional parts, each of which has the same sign as the argument\&. It stores the integral part as a double in the object pointed to by \fI__iptr\fP\&.
.PP
The \fBmodf()\fP function returns the signed fractional part of \fI__x\fP\&.
.PP
\fBNote:\fP
.RS 4
This implementation skips writing by zero pointer\&. However, the GCC 4\&.3 can replace this function with inline code that does not permit to use NULL address for the avoiding of storing\&. 
.RE
.PP

.SS "float \fBmodff\fP (float__x, float *__iptr)"The alias for \fBmodf()\fP\&. 
.SS "double \fBpow\fP (double__x, double__y)"The function \fBpow()\fP returns the value of \fI__x\fP to the exponent \fI__y\fP\&. 
.SS "double \fBround\fP (double__x)"The \fBround()\fP function rounds \fI__x\fP to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer)\&. Overflow is impossible\&.
.PP
\fBReturns:\fP
.RS 4
The rounded value\&. If \fI__x\fP is an integral or infinite, \fI__x\fP itself is returned\&. If \fI__x\fP is \fCNaN\fP, then \fCNaN\fP is returned\&. 
.RE
.PP

.SS "int \fBsignbit\fP (double__x)"The \fBsignbit()\fP function returns a nonzero value if the value of \fI__x\fP has its sign bit set\&. This is not the same as `\fI__x\fP < 0\&.0', because IEEE 754 floating point allows zero to be signed\&. The comparison `-0\&.0 < 0\&.0' is false, but `signbit (-0\&.0)' will return a nonzero value\&. 
.SS "double \fBsin\fP (double__x)"The \fBsin()\fP function returns the sine of \fI__x\fP, measured in radians\&. 
.SS "double \fBsinh\fP (double__x)"The \fBsinh()\fP function returns the hyperbolic sine of \fI__x\fP\&. 
.SS "double \fBsqrt\fP (double__x)"The \fBsqrt()\fP function returns the non-negative square root of \fI__x\fP\&. 
.SS "double \fBsquare\fP (double__x)"The function \fBsquare()\fP returns \fI__x * __x\fP\&.
.PP
\fBNote:\fP
.RS 4
This function does not belong to the C standard definition\&. 
.RE
.PP

.SS "double \fBtan\fP (double__x)"The \fBtan()\fP function returns the tangent of \fI__x\fP, measured in radians\&. 
.SS "double \fBtanh\fP (double__x)"The \fBtanh()\fP function returns the hyperbolic tangent of \fI__x\fP\&. 
.SS "double \fBtrunc\fP (double__x)"The \fBtrunc()\fP function rounds \fI__x\fP to the nearest integer not larger in absolute value\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for avr-libc from the source code\&.
